package com.eomcs.oop.ex03;
// 클래스 변수
public class Exam0130_a {

  static class A {
    //클래스 변수 = 스태틱 변수
    //클래스를 로딩하는 순간 자동 생성됨
    //클래스 이름으로 사용한다고 해서 클래스 소속 변수, 클래스 변수라고 함
    //static이 붙어서 스태틱 변수라고 부른다
    //클래스와 같이 Method Area영역에 있다..


    static int v1;
    static boolean v2;

  }
  public static void main(String[] args) {

    A.v1 = 100;
    A.v2 = true;

    System.out.printf("%d, %b\n", A.v1, A.v2);
  }
}
//## 클래스 로딩 과정
//$ java com.eomcs.oop.ex03.Exam0130
//1) Exam0130.class 를 "Method Area 영역"에 로딩한다.
//- 클래스를 외부 저장소에서 내부 저장소인 RAM으로 로딩한다.
//2) 바이트코드 검증(Verify)
//- 클래스의 바이트코드 유효성을 검사한다.
//3) 스태틱 필드 및 메서드 테이블 준비(Prepare)
//- 스태틱 메모리나 클래스 내부에서 사용하는 이름(변수명, 메서드명, 클래스명 등) 목록을 준비한다.
//4) 참조하는 외부 클래스나 인터페이스 검사(Resolve)
//- 다른 클래스나 인터페이스를 참조하는 것이 유효한지 검사한다.
//5) 클래스 초기화시키기
//- 변수 초기화 문장(variable initializers), 스태틱 블록(static initializers)을 실행한다.
//6) main() 메서드를 호출한다.
//- 해당 클래스의 main() 메서드를 실행한다.

//## Exam0130의 main() 메서드 호출
//1) main() 메서드에 선언된 로컬 변수를 "JVM 스택 영역"에 생성한다.
//- args 변수를 스택 영역에 생성한다.
//2) main()의 코드를 실행한다.
//- A.v1 = 100;
//- A.class 를 "Method Area"에 로딩한다.
//- A의 클래스(스태틱) 필드를 "Method Area"에 생성한다.
//- `A.v1 = 100` 문장을 실행한다.
//- A.v2 = true;
//- A 클래스가 이미 로딩되었기 때문에 다시 로딩하지 않는다.
//- `A.v2 = true` 문장을 실행한다.
//- System.out.println() 를 실행한다.
//

//## JVM이 관리하는 메모리 영역
//1) Heap
//- new 명령으로 생성한 인스턴스가 놓인다.
//- 즉 인스턴스 필드가 이 영역에 생성된다.
//- 가비지 컬렉터는 이 메모리의 가비지들을 관리한다.
//2) JVM Stack
//- 각 스레드가 개인적으로 관리하는 메모리 영역이다.
//- 스레드에서 메서드를 호출할 때 메서드의 로컬 변수를 이 영역에 만든다.
//- 메서드가 호출될 때 그 메서드가 사용하는 로컬 변수를 프레임에 담아 만든다.
//- 메서드 호출이 끝나면 그 메서드가 소유한 프레임이 삭제된다.
//3) Method Area
//- JVM이 실행하는 바이트코드(.class 파일)를 두는 메모리 영역이다.
//- 즉 클래스 코드가 이 영역에 놓이는 것이다.
//- JVM은 코드를 실행할 때 이 영역에 놓은 명령어를 실행하는 것이다.
//- 주의! Heap에는 개발자가 작성한 명령어가 없다.
//- 개발자가 작성한 클래스, 메서드 등 이런 코드들이 이 영역에 놓이는 것이다.
//- 스태틱 필드를 이 영역에 생성한다.